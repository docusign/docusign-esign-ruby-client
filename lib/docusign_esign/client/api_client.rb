=begin
#DocuSign REST API

#The DocuSign REST API provides you with a powerful, convenient, and simple Web services API for interacting with DocuSign.

OpenAPI spec version: v2
Contact: devcenter@docusign.com
Generated by: https://github.com/swagger-api/swagger-codegen.git

=end

require 'addressable'
require 'date'
require 'json'
require 'logger'
require 'tempfile'
require 'typhoeus'
require 'uri'
require 'jwt'

module DocuSign_eSign
  class ApiClient
    # The Configuration object holding settings to be used in the API client.
    attr_accessor :config

    # Defines the headers to be used in HTTP requests of all API calls by default.
    #
    # @return [Hash]
    attr_accessor :default_headers

    attr_accessor :base_path
    attr_accessor :oauth_base_path

    # Initializes the ApiClient
    # @option config [Configuration] Configuration for initializing the object, default to Configuration.default
    def initialize(config = Configuration.default)
      @config = config
      @user_agent = "Swagger-Codegen/#{VERSION}/ruby"
      @default_headers = {
        'Content-Type' => "application/json",
        'User-Agent' => @user_agent
      }
    end

    def self.default
      @@default ||= ApiClient.new
    end

    # Call an API with given options.
    #
    # @return [Array<(Object, Fixnum, Hash)>] an array of 3 elements:
    #   the data deserialized from response body (could be nil), response status code and response headers.
    def call_api(http_method, path, opts = {})
      request = build_request(http_method, path, opts)
      response = request.run

      if @config.debugging
        @config.logger.debug "HTTP response body ~BEGIN~\n#{response.body}\n~END~\n"
      end

      unless response.success?
        if response.timed_out?
          fail ApiError.new('Connection timed out')
        elsif response.code == 0
          # Errors from libcurl will be made visible here
          fail ApiError.new(:code => 0,
                            :message => response.return_message)
        else
          fail ApiError.new(:code => response.code,
                            :response_headers => response.headers,
                            :response_body => response.body),
               response.status_message
        end
      end

      if opts[:return_type]
        data = deserialize(response, opts[:return_type])
      else
        data = nil
      end
      return data, response.code, response.headers
    end

    # Builds the HTTP request
    #
    # @param [String] http_method HTTP method/verb (e.g. POST)
    # @param [String] path URL path (e.g. /account/new)
    # @option opts [Hash] :header_params Header parameters
    # @option opts [Hash] :query_params Query parameters
    # @option opts [Hash] :form_params Query parameters
    # @option opts [Object] :body HTTP body (JSON/XML)
    # @return [Typhoeus::Request] A Typhoeus Request
    def build_request(http_method, path, opts = {})
      url = build_request_url(path, opts)
      http_method = http_method.to_sym.downcase

      header_params = @default_headers.merge(opts[:header_params] || {})

      # Add SDK default header
      header_params.store("X-DocuSign-SDK", "Ruby")

      query_params = opts[:query_params] || {}
      form_params = opts[:form_params] || {}

      update_params_for_auth! header_params, query_params, opts[:auth_names]

      # set ssl_verifyhosts option based on @config.verify_ssl_host (true/false)
      _verify_ssl_host = @config.verify_ssl_host ? 2 : 0

      req_opts = {
        :method => http_method,
        :headers => header_params,
        :params => query_params,
        :params_encoding => @config.params_encoding,
        :timeout => @config.timeout,
        :ssl_verifypeer => @config.verify_ssl,
        :ssl_verifyhost => _verify_ssl_host,
        :sslcert => @config.cert_file,
        :sslkey => @config.key_file,
        :verbose => @config.debugging
      }

      # set custom cert, if provided
      req_opts[:cainfo] = @config.ssl_ca_cert if @config.ssl_ca_cert

      if [:post, :patch, :put, :delete].include?(http_method)
        req_body = build_request_body(header_params, form_params, opts[:body])
        req_opts.update :body => req_body
        if @config.debugging
          @config.logger.debug "HTTP request body param ~BEGIN~\n#{req_body}\n~END~\n"
        end
      end

      Typhoeus::Request.new(url, req_opts)
    end

    # Check if the given MIME is a JSON MIME.
    # JSON MIME examples:
    #   application/json
    #   application/json; charset=UTF8
    #   APPLICATION/JSON
    #   */*
    # @param [String] mime MIME
    # @return [Boolean] True if the MIME is application/json
    def json_mime?(mime)
       (mime == "*/*") || !(mime =~ /\Aapplication\/json(;.*)?\z/i).nil?
    end

    # Deserialize the response to the given return type.
    #
    # @param [Response] response HTTP response
    # @param [String] return_type some examples: "User", "Array[User]", "Hash[String,Integer]"
    def deserialize(response, return_type)
      body = response.body
      return nil if body.nil? || body.empty?

      # return response body directly for String return type
      return body if return_type == 'String'

      # handle file downloading - save response body into a tmp file and return the File instance
      return download_file(response) if return_type == 'File'

      # ensuring a default content type
      content_type = response.headers['Content-Type'] || 'application/json'

      fail "Content-Type is not supported: #{content_type}" unless json_mime?(content_type)

      begin
        data = JSON.parse("[#{body}]", :symbolize_names => true)[0]
      rescue JSON::ParserError => e
        if %w(String Date DateTime).include?(return_type)
          data = body
        else
          raise e
        end
      end

      convert_to_type data, return_type
    end

    # Convert data to the given return type.
    # @param [Object] data Data to be converted
    # @param [String] return_type Return type
    # @return [Mixed] Data in a particular type
    def convert_to_type(data, return_type)
      return nil if data.nil?
      case return_type
      when 'String'
        data.to_s
      when 'Integer'
        data.to_i
      when 'Float'
        data.to_f
      when 'BOOLEAN'
        data == true
      when 'DateTime'
        # parse date time (expecting ISO 8601 format)
        DateTime.parse data
      when 'Date'
        # parse date time (expecting ISO 8601 format)
        Date.parse data
      when 'Object'
        # generic object (usually a Hash), return directly
        data
      when /\AArray<(.+)>\z/
        # e.g. Array<Pet>
        sub_type = $1
        data.map {|item| convert_to_type(item, sub_type) }
      when /\AHash\<String, (.+)\>\z/
        # e.g. Hash<String, Integer>
        sub_type = $1
        {}.tap do |hash|
          data.each {|k, v| hash[k] = convert_to_type(v, sub_type) }
        end
      else
        # models, e.g. Pet
        DocuSign_eSign.const_get(return_type).new.tap do |model|
          model.build_from_hash data
        end
      end
    end

    # Save response body into a file in (the defined) temporary folder, using the filename
    # from the "Content-Disposition" header if provided, otherwise a random filename.
    #
    # @see Configuration#temp_folder_path
    # @return [Tempfile] the file downloaded
    def download_file(response)
      content_disposition = response.headers['Content-Disposition']
      if content_disposition and content_disposition =~ /filename=/i
        filename = content_disposition[/filename=['"]?([^'"\s]+)['"]?/, 1]
        prefix = sanitize_filename(filename)
      else
        prefix = 'download-'
      end
      prefix = prefix + '-' unless prefix.end_with?('-')

      tempfile = nil
      encoding = response.body.encoding
      Tempfile.open(prefix, @config.temp_folder_path, encoding: encoding) do |file|
        file.write(response.body)
        tempfile = file
      end
      @config.logger.info "Temp file written to #{tempfile.path}, please copy the file to a proper folder "\
                          "with e.g. `FileUtils.cp(tempfile.path, '/new/file/path')` otherwise the temp file "\
                          "will be deleted automatically with GC. It's also recommended to delete the temp file "\
                          "explicitly with `tempfile.delete`"
      tempfile
    end

    # Sanitize filename by removing path.
    # e.g. ../../sun.gif becomes sun.gif
    #
    # @param [String] filename the filename to be sanitized
    # @return [String] the sanitized filename
    def sanitize_filename(filename)
      filename.gsub(/.*[\/\\]/, '')
    end

    def build_request_url(path, opts)
      # Add leading and trailing slashes to path
      path = "/#{path}".gsub(/\/+/, '/')
      return Addressable::URI.escape("https://" + self.get_oauth_base_path + path) if opts[:oauth]
      Addressable::URI.escape(@config.base_url + path)
    end

    # Builds the HTTP request body
    #
    # @param [Hash] header_params Header parameters
    # @param [Hash] form_params Query parameters
    # @param [Object] body HTTP body (JSON/XML)
    # @return [String] HTTP body data in the form of string
    def build_request_body(header_params, form_params, body)
      # http form
      if header_params['Content-Type'] == 'application/x-www-form-urlencoded' ||
          header_params['Content-Type'] == 'multipart/form-data'
        data = {}
        form_params.each do |key, value|
          case value
          when File, Array, nil
            # let typhoeus handle File, Array and nil parameters
            data[key] = value
          else
            data[key] = value.to_s
          end
        end
      elsif body
        data = body.is_a?(String) ? body : body.to_json
      else
        data = nil
      end
      data
    end

    # Update hearder and query params based on authentication settings.
    #
    # @param [Hash] header_params Header parameters
    # @param [Hash] query_params Query parameters
    # @param [String] auth_names Authentication scheme name
    def update_params_for_auth!(header_params, query_params, auth_names)
      Array(auth_names).each do |auth_name|
        auth_setting = @config.auth_settings[auth_name]
        next unless auth_setting
        case auth_setting[:in]
        when 'header' then header_params[auth_setting[:key]] = auth_setting[:value]
        when 'query'  then query_params[auth_setting[:key]] = auth_setting[:value]
        else fail ArgumentError, 'Authentication token must be in `query` of `header`'
        end
      end
    end

    # Sets user agent in HTTP header
    #
    # @param [String] user_agent User agent (e.g. swagger-codegen/ruby/1.0.0)
    def user_agent=(user_agent)
      @user_agent = user_agent
      @default_headers['User-Agent'] = @user_agent
    end

    # Return Accept header based on an array of accepts provided.
    # @param [Array] accepts array for Accept
    # @return [String] the Accept header (e.g. application/json)
    def select_header_accept(accepts)
      return nil if accepts.nil? || accepts.empty?
      # use JSON when present, otherwise use all of the provided
      json_accept = accepts.find { |s| json_mime?(s) }
      return json_accept || accepts.join(',')
    end

    # Return Content-Type header based on an array of content types provided.
    # @param [Array] content_types array for Content-Type
    # @return [String] the Content-Type header  (e.g. application/json)
    def select_header_content_type(content_types)
      # use application/json by default
      return 'application/json' if content_types.nil? || content_types.empty?
      # use JSON when present, otherwise use the first one
      json_content_type = content_types.find { |s| json_mime?(s) }
      return json_content_type || content_types.first
    end

    # Convert object (array, hash, object, etc) to JSON string.
    # @param [Object] model object to be converted into JSON string
    # @return [String] JSON string representation of the object
    def object_to_http_body(model)
      return model if model.nil? || model.is_a?(String)
      local_body = nil
      if model.is_a?(Array)
        local_body = model.map{|m| object_to_hash(m) }
      else
        local_body = object_to_hash(model)
      end
      local_body.to_json
    end

    # Convert object(non-array) to hash.
    # @param [Object] obj object to be converted into JSON string
    # @return [String] JSON string representation of the object
    def object_to_hash(obj)
      if obj.respond_to?(:to_hash)
        obj.to_hash
      else
        obj
      end
    end

    # Build parameter value according to the given collection format.
    # @param [String] collection_format one of :csv, :ssv, :tsv, :pipes and :multi
    def build_collection_param(param, collection_format)
      case collection_format
      when :csv
        param.join(',')
      when :ssv
        param.join(' ')
      when :tsv
        param.join("\t")
      when :pipes
        param.join('|')
      when :multi
        # return the array directly as typhoeus will handle it as expected
        param
      else
        fail "unknown collection format: #{collection_format.inspect}"
      end
    end

    # Helper method to set base_path
    # @param [String] base_path
    def set_base_path(base_path)
      self.base_path = base_path
    end

    # Helper method to set oauth base path
    # @param [String] oauth_base_path if passed nil it will determined from base_path
    def set_oauth_base_path(oauth_base_path=nil)
      self.oauth_base_path = oauth_base_path if oauth_base_path
      return if self.oauth_base_path

      # did we need this check as we can determine it from base path
      #raise ArgumentError.new('oAuthBasePath cannot be empty')  unless oauth_base_path

      # Derive OAuth Base Path if not given
      if self.base_path.start_with?("https://demo") or self.base_path.start_with?("http://demo")
        self.oauth_base_path = OAuth::DEMO_OAUTH_BASE_PATH
      elsif self.base_path.start_with?("https://stage") or self.base_path.start_with?("http://stage")
        self.oauth_base_path = OAuth::STAGE_OAUTH_BASE_PATH
      else
        self.oauth_base_path = OAuth::PRODUCTION_OAUTH_BASE_PATH
      end
    end

    # Helper method to get oauth base path
    def get_oauth_base_path
      if !self.oauth_base_path
        self.set_oauth_base_path()
      end
      self.oauth_base_path
    end

    # Helper method to configure the OAuth accessCode/implicit flow parameters
    # @param [String] client_id DocuSign OAuth Client Id(AKA Integrator Key)
    # @param scopes The list of requested scopes.  Client applications may be scoped to a limited set of system access.
    # @param [String] redirect_uri This determines where to deliver the response containing the authorization code
    # @param [String] response_type Determines the response type of the authorization request, NOTE: these response types are mutually exclusive for a client application. A public/native client application may only request a response type
    #          of "token". A private/trusted client application may only request a response type of "code".
    # @param [String] state Allows for arbitrary state that may be useful to your application. The value in this parameter
    #             will be round-tripped along with the response so you can make sure it didn't change.
    # @return [String]
    def get_authorization_uri(client_id, scopes, redirect_uri, response_type, state=nil)
      self.oauth_base_path ||= self.get_oauth_base_path

      scopes = scopes.join(' ') if scopes.kind_of?(Array)
      scopes = OAuth::SCOPE_SIGNATURE if scopes.empty?

      uri = "https://%{base_path}/oauth/auth?response_type=%{response_type}&scope=%{scopes}&client_id=%{client_id}&redirect_uri=%{redirect_uri}"
      uri += "&state=%{state}" if state
      uri  % {base_path: self.oauth_base_path, response_type:response_type, scopes: scopes, client_id: client_id, redirect_uri: redirect_uri, state: state}
    end

    # Request JWT User Token
    # @param [String] client_id DocuSign OAuth Client Id(AKA Integrator Key)
    # @param [String] user_id DocuSign user Id to be impersonated
    # @param [String] private_key_or_filename the RSA private key
    # @param [Number] expires_in number of seconds remaining before the JWT assertion is considered as invalid
    # @param scopes The list of requested scopes.  Client applications may be scoped to a limited set of system access.
    # @return [OAuth::OAuthToken]
    def request_jwt_user_token(client_id, user_id, private_key_or_filename, expires_in = 3600,scopes=OAuth::SCOPE_SIGNATURE)
      raise ArgumentError.new('client_id cannot be empty')  if client_id.empty?
      raise ArgumentError.new('user_id cannot be empty')  if user_id.empty?
      raise ArgumentError.new('private_key_or_filename cannot be empty')  if private_key_or_filename.empty?

      scopes = scopes.join(' ') if scopes.kind_of?(Array)
      scopes = OAuth::SCOPE_SIGNATURE if scopes.empty?
      expires_in = 3600 if expires_in > 3600
      now = Time.now.to_i
      claim = {
        "iss" => client_id,
        "sub" => user_id,
        "aud" => self.get_oauth_base_path,
        "iat" => now,
        "exp" => now + expires_in,
        "scope"=> scopes
      }

      private_key = if private_key_or_filename.include?("-----BEGIN RSA PRIVATE KEY-----")
                      private_key_or_filename
                    else
                      File.read(private_key_or_filename)
                    end

      private_key_bytes = OpenSSL::PKey::RSA.new private_key
      token = JWT.encode claim, private_key_bytes, 'RS256'
      params = {
          :header_params => {"Content-Type" => "application/x-www-form-urlencoded"},
          :form_params => {
              "assertion" => token,
              "grant_type" => OAuth::GRANT_TYPE_JWT
          },
          :return_type => 'OAuth::OAuthToken',
          :oauth => true
      }
      data, status_code, headers = self.call_api("POST", "/oauth/token", params)

      raise ApiError.new('Some error accrued during process') if data.nil?

      self.set_default_header('Authorization', data.token_type + ' ' + data.access_token)
      data
    end

    # Request JWT User Token
    # @param [String] client_id DocuSign OAuth Client Id(AKA Integrator Key)
    # @param [String] private_key_or_filename the RSA private key
    # @param [Number] expires_in number of seconds remaining before the JWT assertion is considered as invalid
    # @param scopes The list of requested scopes.  Client applications may be scoped to a limited set of system access.
    # @return [OAuth::OAuthToken]
    def request_jwt_application_token(client_id, private_key_or_filename, expires_in = 3600,scopes=OAuth::SCOPE_SIGNATURE)
      raise ArgumentError.new('client_id cannot be empty')  if client_id.empty?
      raise ArgumentError.new('private_key_or_filename cannot be empty')  if private_key_or_filename.empty?

      scopes = scopes.join(' ') if scopes.kind_of?(Array)
      scopes = OAuth::SCOPE_SIGNATURE if scopes.empty?
      expires_in = 3600 if expires_in > 3600
      now = Time.now.to_i
      claim = {
          "iss" => client_id,
          "aud" => self.get_oauth_base_path,
          "iat" => now,
          "exp" => now + expires_in,
          "scope"=> scopes
      }
      
      private_key = if private_key_or_filename.include?("-----BEGIN RSA PRIVATE KEY-----")
                      private_key_or_filename
                    else
                      File.read(private_key_or_filename)
                    end

      private_key_bytes = OpenSSL::PKey::RSA.new private_key
      token = JWT.encode claim, private_key_bytes, 'RS256'
      params = {
          :header_params => {"Content-Type" => "application/x-www-form-urlencoded"},
          :form_params => {
              "assertion" => token,
              "grant_type" => OAuth::GRANT_TYPE_JWT
          },
          :return_type => 'OAuth::OAuthToken',
          :oauth => true
      }
      data, status_code, headers = self.call_api("POST", "/oauth/token", params)

      raise ApiError.new('Some error accrued during process') if data.nil?

      self.set_default_header('Authorization', data.token_type + ' ' + data.access_token)
      data
    end

    # Get User Info method takes the accessToken to retrieve User Account Data.
    # @param [String] access_token
    # @return [OAuth::UserInfo]
    def get_user_info(access_token)
      raise ArgumentError.new('Cannot find a valid access token. Cannot find a valid access token.')  if access_token.empty?

      params = {
          :header_params => {"Authorization" => 'Bearer ' + access_token},
          :return_type => 'OAuth::UserInfo',
          :oauth => true
      }
      data, status_code, headers = self.call_api("GET", '/oauth/userinfo', params)
      data
    end

    # GenerateAccessToken will exchange the authorization code for an access token and refresh tokens.
    # @param [String] client_id DocuSign OAuth Client Id(AKA Integrator Key)
    # @param [String] client_secret The secret key you generated when you set up the integration in DocuSign Admin console.
    # @param [String] code The authorization code
    def generate_access_token(client_id, client_secret, code)
      raise ArgumentError.new('client_id cannot be empty')  if client_id.empty?
      raise ArgumentError.new('client_secret cannot be empty')  if client_secret.empty?
      raise ArgumentError.new('code cannot be empty')  if code.empty?

      authcode = "Basic " + Base64.strict_encode64("#{client_id}:#{client_secret}")
      params = {
          :header_params => {
              "Authorization" => authcode,
              "Content-Type" => "application/x-www-form-urlencoded"
          },
          :form_params => {
            "grant_type" => 'authorization_code',
            "code" => code,
          },
          :return_type => 'OAuth::OAuthToken',
          :oauth => true
      }
      data, status_code, headers = self.call_api("POST", '/oauth/token', params)
      abort(data.inspect)

    end

    def set_access_token(token_obj)
      self.default_headers['Authorization'] = token_obj.access_token
    end

    # Helper method to add default header params
    # @param [String] header_name
    # @param [String] header_value
    def set_default_header(header_name, header_value)
        @default_headers[header_name] = header_value
    end
  end
end
